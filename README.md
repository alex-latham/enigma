# ENIGMA

## Learning Goals / Areas of Focus
* Practice breaking a program into logical components
* Build classes that demonstrate single responsibilities
* Test drive a well-designed Object Oriented solution
* Work with file i/o

## Overview
In this project you’ll use Ruby to build a tool for cracking an encryption algorithm. Make sure you understand the Encryption Algorithm and plan out what classes you may need prior to starting.

Additionally, you will self assess your project before your evaluation. Make sure you read through the Evaluation Rubric prior to beginning so that you know what is expected of this project.

* [Project Page](https://backend.turing.io/module1/projects/enigma/index)
* [Setup](https://backend.turing.io/module1/projects/enigma/setup)
* [Encryption Algorithm](https://backend.turing.io/module1/projects/enigma/encryption)
* [Project Requirements](https://backend.turing.io/module1/projects/enigma/requirements)
* [Submission](https://backend.turing.io/module1/projects/enigma/submission)
* [Evaluation Rubric](https://backend.turing.io/module1/projects/enigma/rubric)

## Self Assessment
* **Functionality: 3** [cracking for a 4]
  - Enigma Class with encrypt and decrypt  methods successfully implemented. Encrypt/decrypt command line interfaces successfully implemented.
* **Object Oriented Programming: 3** [modules for a 4]
  - Project is broken into logical components that are appropriately encapsulated. No classes are unreasonably small or large, or contain knowledge/information/behavior that they shouldn’t know about. Student can articulate the single responsibilities of the various components.
* **Ruby Conventions and Mechanics: 4**
  - Classes, methods, and variables are well named so that they clearly communicate their purpose. Code is all properly indented and syntax is consistent. No methods are longer than 10 lines long. Most enumerables/data structures chosen are the most efficient tool for a given job, and students can speak as to why those enumerables/data structures were chosen.
* **Test Driven Development: 4**
  - Mocks and/or stubs are used appropriately to ensure two or more of the following: testing is more robust (i.e., testing methods that might not otherwise be tested due to factors like randomness or user input), testing is more efficient, or that classes can be tested without relying on functionality from other classes. Students are able to speak as to how mocks and/or stubs are fulfilling the above conditions. Test coverage metrics show 100% coverage.
* **Version Control: 4**
  - At least 40 commits. All pull requests include related and logical chunks of functionality, and are named and documented to clearly communicate the purpose of the pull request. No commits include multiple pieces of functionality. No commit message is ambiguous.
